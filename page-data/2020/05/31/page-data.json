{"componentChunkName":"component---src-templates-blog-post-js","path":"/2020/05/31/","result":{"data":{"site":{"siteMetadata":{"title":"Pensando em Códigos"}},"markdownRemark":{"id":"cd42a350-c971-5f6b-94e6-ad5482a99c1d","excerpt":"Um tutorial passando pelos pontos básicos da utilização da biblioteca Bull para gerenciar filas de tarefas assíncronas em aplicações NodeJs. O que é Bull? Bull…","html":"<p>Um tutorial passando pelos pontos básicos da utilização da biblioteca <a href=\"https://github.com/OptimalBits/bull\" target=\"_blank\" rel=\"noopener noreferrer\">Bull</a> para gerenciar filas de tarefas assíncronas em aplicações <a href=\"https://nodejs.org/\" target=\"_blank\" rel=\"noopener noreferrer\">NodeJs</a>.</p>\n<h2>O que é Bull?</h2>\n<p><a href=\"https://github.com/OptimalBits/bull\" target=\"_blank\" rel=\"noopener noreferrer\">Bull</a> é uma biblioteca NodeJS que implementa um rápido e confiável gerenciador de filas de tarefas (<em>job</em>).</p>\n<h4>Filas</h4>\n<p>Fila é uma estrutura de dados muito utilizada no desenvolvimento de aplicações e é definida de forma simples como: o primeiro elemento que entra na fila é o primeiro que sai. O termo que utilizamos em inglês para esse algoritmo é <a href=\"https://pt.wikipedia.org/wiki/FIFO\" target=\"_blank\" rel=\"noopener noreferrer\">FIFO</a> (<em>first In, first out</em>).</p>\n<p>Filas de tarefas assíncronas são muito utilizadas em arquiteturas de sistemas como forma de delegar tarefas para outros processos e liberar a execução do processo principal. Em aplicações web, o cliente fica aguardando uma requisição http e o servidor pode utilizar uma fila de tarefas para responder a requisição, delegando tarefas demoradas, como envio de emails, para outros sistemas que irão consumir as tarefas da fila.</p>\n<!-- Vantagem do uso de filas: processamento assíncrono, paralelismo, falhas... -->\n<h4>Redis</h4>\n<p><a href=\"https://redis.io/\" target=\"_blank\" rel=\"noopener noreferrer\">Redis</a> é um banco de dados <em>NoSQL</em> muito popular e performático que armazena os dados numa estrutura chave-valor. O Bull utiliza Redis como infraestrutura para controlar e persistir as filas. Assim é necessário o endereço de uma instância Redis no ar.</p>\n<p>Não é necessário entender como Bull usa e persiste as filas no Redis, tudo fica abstraído.</p>\n<h2>Tutorial</h2>\n<p>Nesse tutorial, vamos ver os pontos fundamentais do código relativos ao uso do Bull. Para ver a aplicação completa, veja o projeto <a href=\"https://github.com/giovanibr/bull-demo\" target=\"_blank\" rel=\"noopener noreferrer\">bull-demo</a>.</p>\n<h4>Criação da fila</h4>\n<p>O primeiro passo é criar a própria fila de tarefas.</p>\n<p>Importe a biblioteca e instancie uma nova fila passando nos parâmetros o endereço do seu servidor Redis. O construtor <strong>Queue</strong> aceita muitos parâmetros opcionais para customizar o comportamento da fila. Para mais detalhes, veja <a href=\"https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#queue\" target=\"_blank\" rel=\"noopener noreferrer\">REFERENCE.md#queue</a>.</p>\n<pre><code class=\"language-javascript\">const Queue = require('bull');\n\nconst minhaFila = new Queue('minhaFila', {\n    redis: {\n        host: \"127.0.0.1\",\n        port: \"6379\"\n    },\n    prefix: 'bulldemo';\n});\n</code></pre>\n<h4>Adicionando trabalhos a fila</h4>\n<p>O segundo passo é definir a inclusão da tarefa na fila. </p>\n<p>A fila criada tem um método <strong>queue.add()</strong> para adicionar tarefas. Esse método recebe um objeto específico de negócio (um email a ser enviado ou um lote a ser processado por exemplo) e também pode receber opções onde é possível programar o comportamento da tarefa na fila como tempo de espera, um numero de tentativas no caso de erro, etc. Para ver mais opções, consultar <a href=\"https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#queueadd\" target=\"_blank\" rel=\"noopener noreferrer\">REFERENCE.md#queueadd</a>. </p>\n<pre><code class=\"language-javascript\">const options = {\n    delay: 10000, // 10 seg in ms\n    attempts: 5,\n};\n\nconst dadosJob = {\n    \"numero\": 12345\n};\n\nminhaFila.add(dadosJob, options);\n</code></pre>\n<h4>Definição do consumidor</h4>\n<p>O terceiro passo é definir quem vai tratar as tarefas da fila.</p>\n<p>O consumidor é definido por uma função que vai ser chamada toda vez que uma tarefa for retirada da fila de acordo com as configurações. Essa função recebe como parâmetros a tarefa <strong>job</strong>, e o <em>callback</em> opcional <strong>done</strong>.</p>\n<p>A instancia da tarefa contêm todos os dados relativos a sua execução. Os dados que foram passados na criação da tarefa podem ser acessados pela propriedade <strong>job.data</strong>. Para ver todas as propriedades e métodos do objeto, ver <a href=\"https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#job\" target=\"_blank\" rel=\"noopener noreferrer\">REFERENCE.md#job</a>.</p>\n<p>O <em>callback</em> <strong>done</strong> permite concluir a tarefa com êxito ou com erro, dependendo do que vai ser feito com os dados passados.</p>\n<pre><code class=\"language-javascript\">function (job, done) {\n    //progresso\n    job.progress(100);\n\n    // chamada de sucesso \n    done(null, \"Feito\");\n\n    // ou chamada de erro\n    done(new Error('Deu erro!'));\n\n    // ou erro não tratado, Bull reage do msm jeito\n    throw new Error('Erro inesperado');\n}\n</code></pre>\n<p>A função também pode trabalhar com <em>promisses</em> ao invés do <em>callback</em>. </p>\n<pre><code class=\"language-javascript\">function (job) {\n    return new Promise(function(resolve, reject) {\n        // sucesso \n        //resolve(\"Feito\");\n\n        // erro\n        reject(new Error('Deu erro!'));\n\n        erro não tratado, Bull reage do msm jeito\n        throw new Error('Erro inesperado');\n    });\n}\n</code></pre>\n<h4>Definição dos <em>event listeners</em></h4>\n<p>O último passo é definir callbacks para os eventos da fila.</p>\n<p>A fila emite eventos que são muito úteis. Podemos programar ações para cada etapa no ciclo de vida da tarefa (esperando, ativa, finalizada). Podemos também definir o que vai ser feito no caso de erro. </p>\n<p>Para uma lista com todos os eventos, consultar <a href=\"https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#events\" target=\"_blank\" rel=\"noopener noreferrer\">REFERENCE.md#events</a>.</p>\n<pre><code class=\"language-javascript\">//   caminho feliz [waiting, active, completed]\nminhaFila.on('waiting', job => {\n    console.log('Job recebido!');\n});\n\nminhaFila.on('active', function(job, jobPromise){\n    console.log(`Job começou`);\n})\n\nminhaFila.on('completed', function(job, result) {\n    console.log(`${result}, job finalizado com sucesso`);\n    // remove job da fila\n    job.remove();\n});\n\nminhaFila.on('failed', function(job, error){\n    console.log(`Job falhou`, error);\n    // retry\n    job.retry();\n});\n</code></pre>\n<h2>Projeto Demo</h2>\n<p>O projeto <a href=\"https://github.com/giovanibr/bull-demo\" target=\"_blank\" rel=\"noopener noreferrer\">bull-demo</a> está funcional e imprime no console todos as etapas do ciclo de vida da tarefa. Ele é uma aplicação NodeJS básica com <a href=\"https://expressjs.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Express</a> com um endpoint POST, que recebe os dados da tarefa e coloca na fila.</p>\n<p> </p>","frontmatter":{"title":"Implementando filas de tarefas com Bull","date":"May 31, 2020","description":"Como gerenciar filas assíncronas em projetos NodeJS com Bull."}}},"pageContext":{"slug":"/2020/05/31/","previous":{"fields":{"slug":"/2020/05/18/"},"frontmatter":{"title":"Funções em Javascript: entidades de primeira classe"}},"next":null}}}